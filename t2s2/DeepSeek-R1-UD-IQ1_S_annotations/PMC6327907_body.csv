event,time
66 years old , 0  
    morbid obesity , 0  
    hypertension , 0  
    hyperlipidemia , 0  
    non-insulin dependent diabetes mellitus , 0  
    coronary artery disease , 0  
    admitted to the hospital , 0  
    sepsis , 0  
    lower extremity ulceration , 0  
    osteomyelitis , 0  
    contacted family members , -336  
    immobilized , -336  
    collapsed floor , -336  
    without access to hydration , -336  
    squalid living condition , -336  
    refused outside assistance , -336  
    requested medical attention , -336  
    transported by emergency medical services , -336  
    anxious , 0  
    temperature 99.8o F , 0  
    pulse 109 beats per minute , 0  
    blood pressure 128/60 mm Hg , 0  
    respiratory rate 18 breaths per minute ,## 数据结构：堆的应用
### 1.堆排序,
#### 1.1 堆排序的思想,
借助堆来实现数组的排序。要完成从大到小排序，我们需要建造大堆，而从小到大排序，我们需要建造小堆。不是使用堆的其他复杂的操作，而只是用堆的建立和堆的删除，也就是把堆中的元素删除之后，这个位置我就不会再访问了，而把堆的删除操作应用在排序上。例如如果要把数组从小到大排列，那么我可以把数组建成一个小堆，此时堆顶的元素就是最小的元素，之后把堆顶元素和数组末尾的元素交换，此时堆顶元素已经是数组末尾的元素了，之后对这个堆进行删除操作，也就是重新调整堆，使得新的堆顶元素出现，之后继续和此时数组末尾的元素交换，直到最后数组排好序。这里我们默认的是升堆，也就是说，在堆的物理结构上，父节点比子节点小，而如果是降堆，父节点比子节点大。,
所以，堆排序的思想可以总结为：将数组调整为一个堆，之后利用堆的删除操作来逐个取出堆顶的元素，放置在数组的末尾，从而完成排序。,
不过，对于堆排序来说，升序的话应该建立大堆还是小堆呢？假设建立大堆，也就是父节点比子节点大，堆顶元素是最大的元素，此时，如果将堆顶元素和数组末尾元素交换，那么此时最大的元素已经被放置在数组末尾了，之后对堆进行删除操作，即调整堆，此时堆顶的元素是次大的元素，然后和此时数组末尾的元素交换，也就是倒数第二个元素，此时次大的元素也被放置在合适的位置了。这样的操作下来，最后数组就会变得升序排列。所以升序需要建立大堆，降序需要建立小堆。,
所以堆排序的具体步骤为：,
1. 将数组调整成一个堆，如果是升序排列，则调整成大堆；如果是降序排列，则调整成小堆。,
2. 将堆顶元素与堆的最后一个元素（数组的末尾）交换。,
3. 对堆进行调整，使得堆恢复为一个正常的堆，但是不包含最后一个元素（此时数组末尾的元素已经被放置好，不需要再调整）。,
4. 重复步骤2和3，直到所有元素都被交换到正确的位置。,
那么，堆排序的时间复杂度是多少呢？首先，建立堆的过程时间复杂度是O(N)，因为对于每个非叶子节点，最多调整一次。其次，对于每次交换后的调整操作，时间复杂度是O(logN)，而这个过程需要执行N次，所以整个堆排序的时间复杂度是O(N + N logN) = O(N logN)。,
所以堆排序的时间复杂度是O(N logN)，并且空间复杂度是O(1)，因为不需要额外空间，只是对数组进行操作。,
#### 1.2 堆排序的实现,
现在，我们以升序排列为例，说明如何实现堆排序。首先，我们需要将数组调整成大堆，然后每次将堆顶元素（最大值）与数组末尾元素交换，然后调整堆使其恢复成大堆，但排除已交换的元素。因此，我们需要一个函数来调整堆，使得每次交换后的堆能够保持大堆的结构。,
具体来说，堆排序的实现分为两个步骤：第一步是建立堆，第二步是进行堆排序。在建立堆的过程中，我们需要从最后一个非叶子节点开始，逐个调整子树为大堆。然后，在堆排序的过程中，每次将堆顶元素和数组末尾元素交换，然后调整堆结构。,
"例如，给定数组：[3, 4, 5, 2, 7, 6, 8, 1]",
首先，将其调整为大堆：,
"假设数组调整后的大堆结构为：[8, 7, 6, 1, 3, 5,8，2]，具体可能需要重新调整。",
不过，在代码实现中，建立大堆可以通过从最后一个非叶子节点开始，逐步向上调整，直到整个数组成为大堆。,
建立堆之后，每次将堆顶元素（最大值）和当前数组的末尾元素交换，然后排除末尾元素，调整堆结构。,
下面，我们具体看一下如何实现堆排序的代码：,
```c,
"void Swap(int *a, int *b)",
{,
    int tmp = *a;,
    *a = *b;,
    *b = tmp;,
},
"void AdjustDown(int *arr, int n, int parent)",
{,
    int child = parent * 2 + 1; // 左孩子,
    while (child < n),
    {,
        // 找到左右孩子中较大的那个,
        if (child + 1 < n && arr[child + 1] > arr[child]),
        {,
            child++;,
        },
        // 如果父节点比孩子小，交换,
        if (arr[parent] < arr[child]),
        {,
"            Swap(&arr[parent], &arr[child]);",
            parent = child;,
            child = parent * 2 + 1;,
        },
        else,
        {,
            break;,
        },
    },
},
"void HeapSort(int *arr, int n)",
{,
    // 建立大堆,
    for (int i = (n - 1 - 1) / 2; i >= 0; i--) // 从最后一个非叶子节点开始调整,
    {,
"        AdjustDown(arr, n, i);",
    },
    // 排序,
    for (int i = n - 1; i > 0; i--),
    {,
"        Swap(&arr[0], &arr[i]); // 交换堆顶和数组末尾的元素",
"        AdjustDown(arr, i, 0); // 调整堆，排除最后一个元素",
    },
},
```,
上面的代码中，AdjustDown函数用于向下调整堆，使得以parent为根节点的子树成为一个大堆。HeapSort函数中，首先通过从最后一个非叶子节点开始，逐个调整子树为大堆，从而建立整个大堆。然后，通过每次交换堆顶元素和数组末尾元素，然后调整堆结构，使得剩下的元素仍然构成一个大堆，直到所有元素都交换到正确的位置。,
需要注意的是，AdjustDown函数中的参数i在每次排序循环中都是递减的，表示排除已经交换到末尾的元素，只调整前面的元素。,
不过，在AdjustDown的实现中，是否应该使用上移操作呢？其实，当交换堆顶元素和末尾元素之后，堆顶的元素可能破坏堆的结构，此时需要从上到下的调整，即向下调整。所以AdjustDown函数是正确的选择。,
例如，在交换堆顶元素和末尾元素之后，新的堆顶元素是原本的最后一个元素，可能是一个较小的值，此时需要从堆顶开始调整，使得整个堆恢复为大堆的结构。这正是AdjustDown函数的作用。,
在AdjustDown函数中，parent被初始化为0，然后逐步向下调整，使得整个堆恢复为大堆。,
总结来说，堆排序的核心是建立堆和调整堆的过程，通过交换堆顶元素和数组末尾元素，逐步将最大值放置在数组末尾，从而达到排序的目的。,
### 2.TopK问题,
TopK问题是指从一个数据集合中找出前K个最大或最小的元素。例如，从100亿个数据中找到前10个最大的数据。通常，当数据量非常大时，无法将所有数据加载到内存中进行排序，因此需要使用高效的算法来解决这个问题。,
#### 2.1 TopK问题的解决方法,
TopK问题的一个解决方案是使用堆数据结构。具体来说：,
- 如果我们需要找出前K个最大的元素，我们可以维护一个包含K个元素的小堆。当有新元素加入时，如果新元素比堆顶元素大，则替换堆顶元素，并调整堆结构，保持小堆的性质。这样，堆顶元素始终是K个元素中的最小值，当所有元素处理完毕后，堆中的元素即为前K个最大的元素。,
- 同理，如果我们需要找出前K个最小的元素，我们可以维护一个包含K个元素的大堆。当有新元素加入时，如果新元素比堆顶元素小，则替换堆顶元素，并调整堆结构，保持大堆的性质。这样，堆顶元素始终是K个元素中的最大值，当所有元素处理完毕后，堆中的元素即为前K个最小的元素。,
这种方法的优势在于，无论数据量多大，只需要维护一个大小为K的堆，时间复杂度是O(N logK)，而如果对所有数据进行排序，时间复杂度是O(N logN)，当K远小于N时，前者更加高效。,
#### 2.2 TopK问题的代码实现,
例如，假设我们需要从一个包含N个元素的数组中找出前K个最大的元素。我们可以使用一个小堆来实现这一目标。具体步骤如下：,
1. 创建一个空的小堆。,
2. 遍历数组中的每个元素：,
   - 如果堆中的元素数量小于K，直接将元素加入堆中。,
   - 否则，如果当前元素大于堆顶元素，替换堆顶元素，并调整堆结构以保持小堆的性质。,
3. 遍历完成后，堆中的元素即为前K个最大的元素。,
下面是一个具体的代码示例：,
```c,
"void AdjustUp(int *heap, int child)",
{,
    int parent = (child - 1) / 2;,
    while (child > 0),
    {,
        if (heap[child] < heap[parent]),
        {,
"            Swap(&heap[child], &heap[parent]);",
            child = parent;,
            parent = (child - 1) / 2;,
        },
        else,
        {,
            break;,
        },
    },
},
"void AdjustDown(int *heap, int k, int parent)",
{,
    int child = parent * 2 + 1;,
    while (child < k),
    {,
        if (child + 1 < k && heap[child + 1] < heap[child]),
        {,
            child++;,
        },
        if (heap[parent] > heap[child]),
        {,
"            Swap(&heap[parent], &heap[child]);",
            parent = child;,
            child = parent * 2 + 1;,
        },
        else,
        {,
            break;,
        },
    },
},
"void TopK(int *arr, int n, int k)",
{,
    // 假设arr的前k个元素初始化为堆,
    int *heap = (int *)malloc(sizeof(int) * k);,
    for (int i = 0; i < k; i++),
    {,
        heap[i] = arr[i];,
    },
    // 调整成小堆,
    for (int i = (k - 1 - 1) / 2; i >= 0; i--),
    {,
"        AdjustDown(heap, k, i);",
    },
    // 处理剩下的元素,
    for (int i = k; i < n; i++),
    {,
        if (arr[i] > heap[0]),
        {,
            heap[0] = arr[i];,
"            AdjustDown(heap, k, 0);",
        },
    },
    // 输出堆中的元素,
    for (int i = 0; i < k; i++),
    {,
"        printf(""%d "", heap[i]);",
    },
    free(heap);,
},
```,
在这个示例中，我们首先将数组的前K个元素初始化为一个小堆。然后，遍历数组的剩余元素，如果当前元素大于堆顶元素，替换堆顶元素，并向下调整堆结构，以维持小堆的性质。最终，堆中的元素即为前K个最大的元素。,
需要注意的是，这里使用了两种调整堆的方法：AdjustUp和AdjustDown。在初始化堆时，我们使用向下调整方法将前K个元素调整为小堆。在处理后续元素时，每次替换堆顶元素后，使用向下调整方法恢复小堆的结构。,
这种方法的正确性在于，每次替换堆顶元素后，堆的大小保持不变，而堆顶元素被更大的元素替换，从而保持堆中的元素是当前最大的K个元素中的最小值。这样，最终堆中的元素即为前K个最大的元素。,
不过，在实际应用中，当数据量非常大时，可能需要从文件中读取数据，并且使用类似的方法来维护堆，而不需要将所有数据一次性加载到内存中。这种方法的时间复杂度是O(N logK)，空间复杂度是O(K)，非常适用于处理大数据量的情况。,
总结来说，TopK问题的解决方法利用了堆的性质，通过维护一个大小为K的堆，高效地找到前K个最大或最小的元素。,
### 3.堆的其他应用,
除了堆排序和TopK问题，堆数据结构还有其他多种应用，例如：,
- **优先队列**：堆可以用来实现优先队列，其中每个元素都有优先级，优先级高的元素先被处理。优先队列广泛应用于操作系统调度、网络路由算法等领域。,
9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 ,
